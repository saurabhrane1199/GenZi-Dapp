pragma solidity >=0.4.24;

contract genz {
    
    struct Details{
        uint aadhaar;
        string name;
        address id;
        uint role;
        int bal;
    }

    mapping (address => address) public request;
    mapping (address => address) public auth;
    
    Details [] public details; // array of all the people registered
    mapping (address => uint) public deets; // map address to id in the array

    // function to register the person 
    function _register(uint aadhaar, string memory name, uint role) public {
        details.push(Details(aadhaar,name, msg.sender, role, 0)) ;
        deets[msg.sender]=details.length-1;
    }
    
    struct cropType{
        string name;
        uint premiumPerAcre;    //in wei
        uint coveragePerAcre;   //in wei
    }
    
    struct policy {
        uint policyId;
        address payable user; // farmer address
        address payable [] cover; // array of all investors
        uint [] amtCover; // array of cover paid by each investor
        uint premium;
        uint area;
        string location;
        uint duration;
        uint startTime;
        uint endTime;         //crop's season dependent
        uint coverageAmount;  //depends on crop type
        uint forFlood;
        uint8 cropId;
        uint policySum; // current cover generated by policy 
        policyState state; // see if the policy is still available or not 
        status st; // determine if the policy is closed or not 
    }
    
    enum policyState {Pending, Active, PaidOut, TimedOut}
    enum status {Open,Close}
    
    uint private balance; // holds the amount in the risk pool 
    uint private result = 1;
    uint private claimPolicyId;
    uint public payoutAmount;
    
    policy[] public policies; // holds all the policies
    cropType[2] public cropTypes; //crops defined in constructor
    mapping(address => uint[]) public userPolicies;  //user address to array of policy IDs
    
    constructor()
    public payable
    {
        require(msg.value == 5000 wei, "5000 wei initial funding required");
        
        newCrop(0, "rabi", 1,  7);
        newCrop(1, "kharif", 2,  10);
        balance+=msg.value;
    }
    
    function newCrop(uint8 _cropId,string memory _name, uint _premiumPerAcre, uint _coveragePerAcre) internal {
        cropType memory c = cropType(_name, _premiumPerAcre, _coveragePerAcre);
        cropTypes[_cropId] = c;
    }
    
    function newPolicy ( uint _area, uint _forFlood, uint8 _cropId, uint _duration, string memory _location) public payable{
        require(details[deets[msg.sender]].role == 0, "Only farmer can make a new policy");
        require(msg.value == (cropTypes[_cropId].premiumPerAcre * _area),"Incorrect Premium Amount");
        
        balance += msg.value; // update risk pool balance
        details[deets[msg.sender]].bal -= int(msg.value); // update user balance

        uint pId = policies.length++;
        userPolicies[msg.sender].push(pId);
        policy storage p = policies[pId]; // store the policy in an array

        p.user = msg.sender;
        p.premium = cropTypes[_cropId].premiumPerAcre * _area;
        p.location = _location;
        p.area = _area;
        p.startTime = now;
        p.duration = _duration;
        p.endTime = now + _duration * 30*24*60*60;  //converting months to seconds
        p.coverageAmount = cropTypes[_cropId].coveragePerAcre * _area;
        p.forFlood = _forFlood;
        p.cropId = _cropId;
        p.state = policyState.Active;
        p.st = status.Open;
    }
    
    function coverForPolicy(uint _policyId) external payable{
        require(details[deets[msg.sender]].role == 1, "Only investors can provide money");
        
        policy storage p = policies[_policyId];
        require(msg.value <= p.coverageAmount,"Incorrect Cover Amount");
        require(p.st == status.Open, " Policy is closed cannot cover ");
        require(p.policySum + msg.value <= p.coverageAmount, " Coverage amount exceeded ");
        
        details[deets[msg.sender]].bal -= int(msg.value);
        balance += msg.value;
        userPolicies[msg.sender].push(_policyId);
        p.cover.push(msg.sender);
        p.amtCover.push(msg.value);
        p.policySum += msg.value;
        
        if (p.policySum == p.coverageAmount){
            p.st = status.Close;
        }
    }
    
    function claim(uint _policyId) public {
        require(msg.sender == policies[_policyId].user, "User Not Authorized");
        require(policies[_policyId].state == policyState.Active, "Policy Not Active");
        require(policies[_policyId].st == status.Close, "Coverage Amount is not fullfilled");

        if(now > policies[_policyId].endTime)
        {
            policies[_policyId].state = policyState.TimedOut;
            revert("Policy's period has Ended.");
        }
        
        claimPolicyId = _policyId;
        
        /* TODO check weather condition over here TODO*/
        
        // check condition and accordingly pay 
        if(result==0){
            payoutAmount = uint(policies[claimPolicyId].coverageAmount);
            policies[claimPolicyId].user.transfer(payoutAmount);
            policies[claimPolicyId].state = policyState.PaidOut;
            balance-=payoutAmount;
            details[deets[policies[claimPolicyId].user]].bal += int(payoutAmount);
        }
        else{
            uint x = sum(policies[claimPolicyId].amtCover);
            
            for (uint i=0; i<policies[claimPolicyId].cover.length; i++){
                uint ratio = uint((policies[claimPolicyId].amtCover[i]) * 100)/uint(x);
                payoutAmount = uint( policies[claimPolicyId].premium * ratio/100 ) + uint(policies[claimPolicyId].amtCover[i]);
                policies[claimPolicyId].cover[i].transfer(payoutAmount);
                policies[claimPolicyId].state = policyState.PaidOut;
                balance-=payoutAmount;
                details[deets[policies[claimPolicyId].cover[i]]].bal += int(payoutAmount);
            }
        }
    }
    
    function sum(uint [] memory x) public pure returns(uint){
        uint s = 0;
        for ( uint i = 0; i<x.length; i++){
            s += x[i];
        }
        return s;
    }
    
    // function returns the details of the person calling the function
    function getDetails() public view returns (uint, string memory, uint) {
        return (details[deets[msg.sender]].aadhaar, details[deets[msg.sender]].name, details[deets[msg.sender]].role );
    }
    
    // function to get the balance of the user 
    function getBalanceUser() public view returns(int){
        return details[deets[msg.sender]].bal;
    }
    
    // function to get the balance of the smart contract
    function getBalance() public view returns(uint){
        return balance;
    }
    
    // function to get all policy of a user
    function getPolicyUser() public view returns(uint[] memory){
        return userPolicies[msg.sender];
    }
    
    // function to get policy details of a particular id
    function getPolicyDetails(uint _policyId) public view returns(uint,address payable,address payable [] memory,uint[] memory,string memory,uint,uint,uint,uint,uint,uint8,policyState){
        policy memory p = policies[_policyId];
        return (_policyId, p.user,p.cover,p.amtCover,p.location,p.premium,p.area,p.startTime,p.endTime,p.coverageAmount,p.cropId,p.state);
    }

    function getPolicyLength() public view returns(uint){
        return policies.length;
    }
    
    // function to request the farmer to view his details
    /*function requestFarmer(address farmerAddress) public {
        // find farmer address using his aadhaar
        require(details[deets[farmerAddress]].role == 0);
        require(details[deets[msg.sender]].role == 1);
        request[farmerAddress] = msg.sender; 
    }

    // called by farmer to authorize an invesotr to view his detials 
    function approveInvestor() public returns (uint, string memory, uint){
        
        require(details[deets[msg.sender]].role == 0);
        address investorAddress = request[msg.sender];
        auth[msg.sender] = investorAddress;

        return (details[deets[msg.sender]].aadhaar, details[deets[msg.sender]].name, details[deets[msg.sender]].role );

    }*/
}
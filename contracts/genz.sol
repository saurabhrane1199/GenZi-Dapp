pragma solidity >=0.5.0;

import "chainlink/v0.5/contracts/ChainlinkClient.sol";

contract genz is ChainlinkClient {
    struct Details {
        uint256 aadhaar;
        string name;
        address id;
        uint256 role;
        int256 bal;
    }

    address private oracle;
    bytes32 private jobId;
    uint256 private fee;

    mapping(address => address) public request;
    mapping(address => address) public auth;

    Details[] public details; // array of all the people registered
    mapping(address => uint256) public deets; // map address to id in the array

    // function to register the person
    function _register(
        uint256 aadhaar,
        string memory name,
        uint256 role
    ) public {
        details.push(Details(aadhaar, name, msg.sender, role, 0));
        deets[msg.sender] = details.length - 1;
    }

    struct cropType {
        string name;
        uint256 premiumPerAcre; //in wei
        uint256 coveragePerAcre; //in wei
    }

    struct policy {
        uint256 policyId;
        address payable user; // farmer address
        address payable[] cover; // array of all investors
        uint256[] amtCover; // array of cover paid by each investor
        uint256 premium;
        uint256 area;
        string location;
        uint256 duration;
        uint256 startTime;
        uint256 endTime; //crop's season dependent
        uint256 coverageAmount; //depends on crop type
        uint256 forFlood;
        uint8 cropId;
        uint256 policySum; // current cover generated by policy
        policyState state; // see if the policy is still available or not
        status st; // determine if the policy is closed or not
    }

    enum policyState {Pending, Active, PaidOut, TimedOut}
    enum status {Open, Close}

    uint256 private balance; // holds the amount in the risk pool
    uint256 private result = 2;
    uint256 private claimPolicyId;
    uint256 public payoutAmount;

    policy[] public policies; // holds all the policies
    cropType[2] public cropTypes; //crops defined in constructor
    mapping(address => uint256[]) public userPolicies; //user address to array of policy IDs

    constructor() public payable {
        require(msg.value == 5000 wei, "5000 wei initial funding required");
        setPublicChainlinkToken();
        oracle = 0xcb65E9b36eB788Ab0F94f06FB3906EcfAF4e055A; // oracle address
        jobId = "ecd449555254420abf55f98469c2fcaa"; //job id
        fee = 0.1 * 10**18; // 0.1 LINK
        newCrop(0, "rabi", 1, 7);
        newCrop(1, "kharif", 2, 10);
        balance += msg.value;
    }

    function newCrop(
        uint8 _cropId,
        string memory _name,
        uint256 _premiumPerAcre,
        uint256 _coveragePerAcre
    ) internal {
        cropType memory c = cropType(_name, _premiumPerAcre, _coveragePerAcre);
        cropTypes[_cropId] = c;
    }

    function newPolicy(
        uint256 _area,
        uint256 _forFlood,
        uint8 _cropId,
        uint256 _duration,
        string memory _location
    ) public payable {
        require(
            details[deets[msg.sender]].role == 0,
            "Only farmer can make a new policy"
        );
        require(
            msg.value == (cropTypes[_cropId].premiumPerAcre * _area),
            "Incorrect Premium Amount"
        );

        balance += msg.value; // update risk pool balance
        details[deets[msg.sender]].bal -= int256(msg.value); // update user balance

        uint256 pId = policies.length++;
        userPolicies[msg.sender].push(pId);
        policy storage p = policies[pId]; // store the policy in an array

        p.user = msg.sender;
        p.premium = cropTypes[_cropId].premiumPerAcre * _area;
        p.location = _location;
        p.area = _area;
        p.startTime = now;
        p.duration = _duration;
        p.endTime = now + _duration * 30 * 24 * 60 * 60; //converting months to seconds
        p.coverageAmount = cropTypes[_cropId].coveragePerAcre * _area;
        p.forFlood = _forFlood;
        p.cropId = _cropId;
        p.state = policyState.Active;
        p.st = status.Open;
    }

    function coverForPolicy(uint256 _policyId) external payable {
        require(
            details[deets[msg.sender]].role == 1,
            "Only investors can provide money"
        );

        policy storage p = policies[_policyId];
        require(msg.value <= p.coverageAmount, "Incorrect Cover Amount");
        require(p.st == status.Open, " Policy is closed cannot cover ");
        require(
            p.policySum + msg.value <= p.coverageAmount,
            " Coverage amount exceeded "
        );

        details[deets[msg.sender]].bal -= int256(msg.value);
        balance = balance + msg.value;
        userPolicies[msg.sender].push(_policyId);
        p.cover.push(msg.sender);
        p.amtCover.push(msg.value);
        p.policySum += msg.value;

        if (p.policySum == p.coverageAmount) {
            p.st = status.Close;
        }
    }

    function claim(
        uint256 _policyId,
        string memory s1,
        string memory s2
    ) public {
        require(msg.sender == policies[_policyId].user, "User Not Authorized");
        require(
            policies[_policyId].state == policyState.Active,
            "Policy Not Active"
        );
        require(
            policies[_policyId].st == status.Close,
            "Coverage Amount is not fullfilled"
        );

        if (now > policies[_policyId].endTime) {
            policies[_policyId].state = policyState.TimedOut;
            revert("Policy's period has Ended.");
        }

        claimPolicyId = _policyId;

        Chainlink.Request memory req = buildChainlinkRequest(
            jobId,
            address(this),
            this.fullfillWeather.selector
        );
        req.add("city", "Mumbai");
        req.add("start_date", s1);
        req.add("end_date", s2);
        string[] memory copyPath = new string[](3);
        copyPath[0] = "data";
        copyPath[1] = "0";
        copyPath[2] = "precip";
        req.addStringArray("copyPath", copyPath);
        // req.addInt("times", 100);
        sendChainlinkRequestTo(oracle, req, fee);

        /* TODO check weather condition over here TODO*/

        // check condition and accordingly pay
        //     if(result == 0){
        //         payoutAmount = uint(policies[claimPolicyId].coverageAmount) + uint(policies[claimPolicyId].premium);
        //         policies[claimPolicyId].user.transfer(payoutAmount);
        //         policies[claimPolicyId].state = policyState.PaidOut;
        //         balance-=payoutAmount;
        //         details[deets[policies[claimPolicyId].user]].bal += int(payoutAmount);
        //     }
        //     else if(result == 1 ){
        //         uint payoutAmountFarmer = uint(policies[claimPolicyId].coverageAmount * 50/100) + uint(policies[claimPolicyId].premium * 50/100);
        //         policies[claimPolicyId].user.transfer(payoutAmountFarmer);
        //         balance-=payoutAmountFarmer;
        //         details[deets[policies[claimPolicyId].user]].bal += int(payoutAmountFarmer);

        //         uint y = sum(policies[claimPolicyId].amtCover);
        //         for (uint j=0 ; j<policies[claimPolicyId].cover.length; j++){
        //             uint ratio1 = uint((policies[claimPolicyId].amtCover[j]) * 100)/uint(y);
        //             uint payoutAmountInv = uint( policies[claimPolicyId].premium * ratio1/100 ) + uint(policies[claimPolicyId].amtCover[j]);
        //             payoutAmountInv = payoutAmountInv * 50/100;
        //             policies[claimPolicyId].cover[j].transfer(payoutAmountInv);
        //             policies[claimPolicyId].state = policyState.PaidOut;
        //             balance-=payoutAmountInv;
        //             details[deets[policies[claimPolicyId].cover[j]]].bal += int(payoutAmountInv);
        //         }
        //     }
        //     else{
        //          uint x = sum(policies[claimPolicyId].amtCover);

        //         for (uint i=0; i<policies[claimPolicyId].cover.length; i++){
        //             uint ratio = uint((policies[claimPolicyId].amtCover[i]) * 100)/uint(x);
        //             payoutAmount = uint( policies[claimPolicyId].premium * ratio/100 ) + uint(policies[claimPolicyId].amtCover[i]);
        //             policies[claimPolicyId].cover[i].transfer(payoutAmount);
        //             policies[claimPolicyId].state = policyState.PaidOut;
        //             balance-=payoutAmount;
        //             details[deets[policies[claimPolicyId].cover[i]]].bal += int(payoutAmount);
        //         }
        // }
    }

    function fullfillWeather(bytes32 _requestId, uint256 _rain)
        public
        recordChainlinkFulfillment(_requestId)
    {
        result = _rain;
        if (result > 15000) {
            payoutAmount =
                uint256(policies[claimPolicyId].coverageAmount) +
                uint256(policies[claimPolicyId].premium);
            policies[claimPolicyId].user.transfer(payoutAmount);
            policies[claimPolicyId].state = policyState.PaidOut;
            balance -= payoutAmount;
            details[deets[policies[claimPolicyId].user]].bal += int256(
                payoutAmount
            );
        } else if (result <= 15000 && result>10000) {
            uint256 payoutAmountFarmer = uint256(
                (policies[claimPolicyId].coverageAmount * 50) / 100
            ) + uint256((policies[claimPolicyId].premium * 50) / 100);
            policies[claimPolicyId].user.transfer(payoutAmountFarmer);
            balance -= payoutAmountFarmer;
            details[deets[policies[claimPolicyId].user]].bal += int256(
                payoutAmountFarmer
            );

            uint256 y = sum(policies[claimPolicyId].amtCover);
            for (uint256 j = 0; j < policies[claimPolicyId].cover.length; j++) {
                uint256 ratio1 = uint256(
                    (policies[claimPolicyId].amtCover[j]) * 100
                ) / uint256(y);
                uint256 payoutAmountInv = uint256(
                    (policies[claimPolicyId].premium * ratio1) / 100
                ) + uint256(policies[claimPolicyId].amtCover[j]);
                payoutAmountInv = (payoutAmountInv * 50) / 100;
                policies[claimPolicyId].cover[j].transfer(payoutAmountInv);
                policies[claimPolicyId].state = policyState.PaidOut;
                balance -= payoutAmountInv;
                details[deets[policies[claimPolicyId].cover[j]]].bal += int256(
                    payoutAmountInv
                );
            }
        } else {
            uint256 x = sum(policies[claimPolicyId].amtCover);

            for (uint256 i = 0; i < policies[claimPolicyId].cover.length; i++) {
                uint256 ratio = uint256(
                    (policies[claimPolicyId].amtCover[i]) * 100
                ) / uint256(x);
                payoutAmount =
                    uint256((policies[claimPolicyId].premium * ratio) / 100) +
                    uint256(policies[claimPolicyId].amtCover[i]);
                policies[claimPolicyId].cover[i].transfer(payoutAmount);
                policies[claimPolicyId].state = policyState.PaidOut;
                balance -= payoutAmount;
                details[deets[policies[claimPolicyId].cover[i]]].bal += int256(
                    payoutAmount
                );
            }
        }
    }

    function sum(uint256[] memory x) public pure returns (uint256) {
        uint256 s = 0;
        for (uint256 i = 0; i < x.length; i++) {
            s += x[i];
        }
        return s;
    }

    // function returns the details of the person calling the function
    function getDetails()
        public
        view
        returns (
            uint256,
            string memory,
            uint256
        )
    {
        return (
            details[deets[msg.sender]].aadhaar,
            details[deets[msg.sender]].name,
            details[deets[msg.sender]].role
        );
    }

    // function to get the balance of the user
    function getBalanceUser() public view returns (int256) {
        return details[deets[msg.sender]].bal;
    }

    // function to get the balance of the smart contract
    function getBalance() public view returns (uint256) {
        return balance;
    }

    // function to get all policy of a user
    function getPolicyUser() public view returns (uint256[] memory) {
        return userPolicies[msg.sender];
    }

    // function to get policy details of a particular id
    // function to get policy details of a particular id
    function getPolicyDetails(uint256 _policyId)
        public
        view
        returns (
            address payable,
            address payable[] memory,
            uint256[] memory,
            string memory,
            uint256[] memory,
            uint8,
            status,
            policyState
        )
    {
        policy memory p = policies[_policyId];
        uint256[] memory a = new uint256[](7);
        a[0] = _policyId;
        a[1] = (p.premium);
        a[2] = (p.area);
        a[3] = (p.startTime);
        a[4] = (p.endTime);
        a[5] = (p.coverageAmount);
        a[6] = (p.policySum);
        return (
            p.user,
            p.cover,
            p.amtCover,
            p.location,
            a,
            p.cropId,
            p.st,
            p.state
        );
    }

    function getPolicyLength() public view returns (uint256) {
        return policies.length;
    }

    function login() public view returns (uint256) {
        for (uint256 i = 0; i < details.length; i++) {
            if (details[i].id == msg.sender) {
                return 1;
            }
        }
        return 0;
    }

    // function to request the farmer to view his details
    /*function requestFarmer(address farmerAddress) public {
        // find farmer address using his aadhaar
        require(details[deets[farmerAddress]].role == 0);
        require(details[deets[msg.sender]].role == 1);
        request[farmerAddress] = msg.sender; 
    }

    // called by farmer to authorize an invesotr to view his detials 
    function approveInvestor() public returns (uint, string memory, uint){
        
        require(details[deets[msg.sender]].role == 0);
        address investorAddress = request[msg.sender];
        auth[msg.sender] = investorAddress;

        return (details[deets[msg.sender]].aadhaar, details[deets[msg.sender]].name, details[deets[msg.sender]].role );

    }*/
}
